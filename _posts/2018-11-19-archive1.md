---
layout: post
title: "Archive1"
date: 2018-11-19
description: "Archive1"
tag: Projs
---

定期存档1.

### 目录

* [IOS项目涉及到的开发知识(20180510)](#ios-relative)
* [IPC(20180806)](#ipc)
* [$\alpha$-Blending(20180829)](#alpha-blending)

### <a name="ios-relative"></a>IOS项目涉及到的开发知识20180510

* [1. ios工程配置相关知识](#ios-config)、[2. 属性和实例变量](#property)、[3. extern、static、const](#esc)、[4. grammar1](#grammar1)、[5. OC与C++混编](#oc-cpp-mex)、[6. ios的黑魔盒](#ios-black-box)、[7. viewDidLoad, viewDidAppear执行顺序](#didload-didappear-sequence)、[8. Singleton与多线程](#singleton)、[9. NSData](#nsdata)、[10. iOS 文件目录](#ios-filedir)、[11. Runloop](#runloop)、[12. ios消息机制](#ios-message)

#### <a name="ios-config"></a>1. ios工程配置相关知识

&emsp;&emsp;一些名词:

+ App ID(Prouct ID): 标识一个或一组App, 与Xcode中的Bundle Identifier一致的或匹配的.
+ CA发布数字证书用以区分通讯各方身份信息.
+ 数字证书: 包含: 公开秘钥[相当于公章]、名称、数字签名; 具有实效性[只在特定的时间段内有效]
+ 根证书: 最根上的证书(如户籍证明), 是信任链的起点.
+ ios证书: 验证App内容是完整、可靠、合法的. 分两类: Development、Production.
+ Development certificate: 用来开发和调试应用程序.
+ Production certificate: 用于分发App.
+ 普通个人开发账号可注册两个Development certificate和两个Development certificate.

&emsp;&emsp;ios app开发调试过程中的开发证书:

+ ios app开发证书的根证书是Apple Worldwide Developer Relations Certification Authority, 他们之间的关系好比于身份证之于户籍.
+ 证书申请: keychain生成CSR[包含开发者身份信息], 同时新增一对public/private key pair. public key随app走, 对app签名进行教研, private key 保存在keychain Access[本地], 以防假冒.
+ Apple Worldwide Developer Relations Certification Authority使用private key对CSR中的public key和开发者身份信息进行加密签名生成数字证书并记录在案.

&emsp;&emsp;证书的安装:

+ 从Apple Member Center下载双击、Xcode添加开发账号自动同步证书和配置文件.
+ build settings > code signing > 配置开发证书.

&emsp;&emsp;Provisioning profile:

+ 打包或真机运行app, 需要: 指明App ID并验证是否于Bundle ID匹配、签名[用证书的私钥签名, 以确定App合法、安全、完整]、确认设备是否授权运行这个app.
+ 而Provisioning profile(pp)涵盖上面提到的: App ID、签名、设备, 它将这三项打包在一起方便在调试和打包时使用, 因此只要在不同的情况下选择不同的pp就行了.
+ pp分为: Development和Distribution两类, 后者主要用于提交到App Store, 这里就不指定设备了.
+ 所有的pp文件被防止在~/Library/MobileDevice/Provisioning Profiles

&emsp;&emsp;开发版pp文件中字段的含义:

+ DeveloperCertificates: 必须这个列表里的证书签名, 否则一定codeSign fail.
+ ProvisionedDevices: 这里配置了设备

&emsp;&emsp;Team PP:

+ 每个Apple开发者账号都对应一个唯一的Team ID.

&emsp;&emsp;App Group

+ ios8以后出现了App Extension, containing App和Extension之间是独立的二进制包, 不可以互访对方的沙盒, extension是containing app的插件.
+ 为了实现containing app和extension之间共享数据, ios 8引入了App Group, 让同一group下的所有app共享数据.
+ extension app ID 于containing app的命名是有规则的.
+ extension app id以containing app id为前缀.
+ 公用证书, 公用证书key pair中的private key进行codeSign

&emsp;&emsp;证书、签名:

+ code signing identity必须与provisioning profile匹配
+ code signing identity中配置的certificate必须在本机keychain access中存在对应的public/private key pair, 否则编译会报错.
+ 上面的合法性验证是WWDRCA.cer完成的.
+ 证书其实就是公钥, 私钥被用来进行数字签名[数字签名就是用哈希算法生成digest]

&emsp;&emsp;真机启动:

+ App在Mac/ios设备上启动时, 会将xcode对其进行的配置与provisioning file(pp)进行匹配校验, 就是看bundle ID是否与app ID匹配, codesign得到的结果是否在pp中, 设备ID是否在pp文件里.
+ ios/mac设备使用codesign所使用的开发证书(dongzhao)来判断App的合法性: 使用证书公钥解出App的signature以确定App是否来源可信; 再计算下app 二进制的哈希结果以确定App没有被篡改过, 内容完整.
+ 基于Provisioning Profile校验了CodeSign的一致性；
+ 基于Certificate校验App的可靠性和完整性；
+ 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。

&emsp;&emsp;多台机器共享开发账户/证书(p12):

+ 在Keychain Access中选中欲导出的certificate或其下private key, 导出p12文件(holds the private key and certificate).
+ 其他Mac机器上双击Certificates.p12即可安装该共享证书. 有了共享证书之后, 在开发者网站上将欲调试的iOS设备注册到该开发者账号名下, 并下载对应证书授权了iOS调试设备的pp文件, 便可在iOS真机设备上开发调试.

##### Reference

- [1. iOS Provisioning Profile(Certificate)与Code Signing详解](http://blog.sina.com.cn/s/blog_82c8198f0102vy4j.html)

#### <a name="property"></a>2. 属性和实例变量

写法一:

```
@interface MyViewController :UIViewController
@property (nonatomic, retain) UIButton *myButton;
@end

```
+ 1. self.myButton调用的是myButton属性的getter/setter方法
+ 2. 实例变量可以理解成C++的成员变量
+ 3. object-c 2.0中@property会自动创建_开头的实例变量

写法二:

```
#import "ViewController.h"

@interface ViewController ()
@property (nonatomic, strong) UIButton *myButton;
@end

@implementation ViewController
@synthesize myButton;

```

归纳总结:

+ `@synthesize`只能出现在`@implementation`代码段中
+ 让编译器自动生成setter和getter
+ `@synthesize myButton = xxx`这种写法指定了与属性对应的实例变量，那么self.myButton其实操作的是实例变量_xxx, 而不是`myButton`了;
+ `@syncthesize myButton`生成的实例变量是`myButton`，也可理解成操作的是`myButton`, 如果没有`@syncthesize myButton`, 生成的实例变量就是`_myButton`

这四条总结起来就是`@synthesize`映射了属性与实例变量，`self.某某`调用的是实例变量的`setter`和`getter`；默认的映射是与之同名的实例变量(可见有了这个关键字生成的是与之同名的实例变量)；没有这个关键字就默认生成`_某某`的实例变量。简记为"做映射, 操作实例, 默认同名"

属性和实例变量的关系：

+ 属性对成员变量扩充了存取方法;
+ 属性默认会生成带下划线的成员变量;
+ 但只声明了变量，是不会有属性的

属性中的参数: @property(nullable, nonatomic, copy)、@property (class, readonly, strong)

#### <a name="esc"></a>3. extern、static、const

简单总结:

+ extern-全局变量修饰，跨文件访问
+ const-修饰右边变量
+ static-定义开始到文件结尾(修饰全局变量)
+ static-定义开始到函数结束或语句块结束(修饰局部变量)
+ static-本文件使用(修饰函数)

`const static`应用场景：本文件中经常使用的字符串常量。

eg1.:

+ `classA.h`文件:

```
@interface ClassA : NSObject
+ (nullable NSUserDefaults *)sharedUserDefaults;
@end

extern NSString * _Nonnull WWKEPostBoxIdentifierHost;
extern NSString * _Nonnull WWKEPostBoxIdentifierShareExtension;
```

+ `classA.m`文件:

```
#import "ClassA.h"

NSString *APPGROUP_NAME = @"group.com.tencent.ww";

NSString *WWKEPostBoxIdentifierHost = @"host";
NSString *WWKEPostBoxIdentifierShareExtension = @"shareext";

@implementation ClassA
+ (nullable NSUserDefaults *)sharedUserDefaults{
    return [[NSUserDefaults alloc] initWithSuiteName:APPGROUP_NAME];
}

@end
```

+ `classB.h`文件：

```
#import "ClassA.h"

@interface ClassB : ClassA

@end

extern NSString * _Nonnull WWKEPostBoxIdentifierShareExtension1;
```

+ `classB.m`文件：

```
    NSString * WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];

    @implementation ClassB
    + (nullable NSUserDefaults *)sharedUserDefaults{
        WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];
        return [[NSUserDefaults alloc] initWithSuiteName:@"sss"];
    }

    @end
```

`NSString * WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];`这行有bug:

```
nitializer element is not a compile-time constant
```

想得通, `WWKEPostBoxIdentifierShareExtension`初始化的时机不能保证在这行之前完成，因此有这个bug。注意，`WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];`这行是没问题的，这说明此时`WWKEPostBoxIdentifierShareExtension`已经初始化完毕。

eg2:

+ `classA.h`和`classA.m`文件不变，`classB.h`变成：

```
#import "ClassA.h"

@interface ClassB : ClassA

@end

```

+ `classB.m`变成：

```
#import "ClassB.h"

NSString *WWKEPostBoxIdentifierHost = @"host";
NSString *WWKEPostBoxIdentifierShareExtension = @"shareext";

@implementation ClassB

@end
```

此时会报链接错误, 注意，`extern`修饰的变量不要出现两次初始化。经调试，只要把任意一处的初始化删掉一个都可通过编译。

##### Reference

- [1. OC中关键字extern、static、const探究](https://www.jianshu.com/p/3fa703e80720)

#### <a name="grammar1"></a>4. grammar1

+ NSUserDefaults: 通过`NSUserDefaults`访问plist文件中的偏好设置
+ 写在`.h`和`.m`中的`@property`有什么区别: 初步看是作用域的问题，后续仔细看下[`@property`](https://jiangxh1992.github.io/ios/2016/10/31/Property%E5%B1%9E%E6%80%A7/)学习下`property`
+ NSFileCoordinator是协调在host app与extension apps之间移动数据的非UI组件
+ CFNotificationCenterGetDarwinNotifyCenter: 1. 系统级的通知中心, 可用于Extension和容器app的交互, 2. NSNotificationCenter，KVO，Delegate都不行，因为Extension和容器app不是一个App. 此外，如果想实现更复杂的进程间的交互，可以使用`MMWormhole`
+ Category和Extension: 一种对类进行扩展的方法， 无需创建子类就可以添加新方法, 可以为任何已经存在的class添加方法, 包括没有源码的类.

##### Reference

- [1. NSUserDefaults](https://www.jianshu.com/p/459c15cf6ce2)
- [2. NSFileCoordinator](https://www.jianshu.com/p/3e3674630190)
- [3. 为什么用](https://www.jianshu.com/p/e807ee6e46e5)

nonatomic

+ 在ios中，一般都声明为非原子的，这处于性能的考虑
+ 在mac OS X中，可以声明为atomic, 因为在mac上不需要怎么考虑性能问题
+ 即使是atomic也不一定能保证是线程安全的，还需要更深层次的锁定机制才行[]

strong与weak

+ ARC是编译器特性而不是运行时特性, 因此不是类似于其他语言的垃圾回收器，其性能与手动内存管理是一样的
+ Strong指针的特点就是可以保持对象的生命，也就是说：当指针获得新值或者不存在时(如局部变量方法返回、实例变量对象释放)对象可能被释放。之所以这里说的是"可能"，理由在于：一个对象可以有多个"拥有者"
+ 默认所有实例变量和局部变量都是Strong指针
+ weak型的指针变量仍然可以指向一个对象，但是不属于对象的拥有者. 也就是说只有使用权, 而不会影响对象的回收。
+ weak型的指针变量自动变为nil是非常方便的，这样阻止了weak指针继续指向已释放对象，避免了野指针的产生，不然会导致非常难于寻找的Bug，空指针消除了类似的问题(野指针跟阳痿差不多)
+ weak指针主要用于“父-子”关系
+ 有了ARC之后，只需要关心对象之间的关联，也就是"谁是谁的拥有者"

##### Reference

- [1. strong属性与weak属性的区别](https://www.jianshu.com/p/f9e5b3f9c088)

#### <a name="oc-cpp-mex"></a>5. OC与C++混编

主要总结C++调用OC的三种情况：

+ 在C++的头文件中写个struct把oc对象藏起来
+ 在C++的头文件中这样`id xxx`
+ 通过c的函数指针把C++和OC结合起来
+ OC对象里函数指针包起实际调用的方法
+ 把OC本身通过void*传给C++对象(与调用无关，只是传递)
+ 把OC的函数指针传给C++对象

详细介绍见参考文章

##### Reference

- [1. 混编](https://awhisper.github.io/2016/05/01/%E6%B7%B7%E7%BC%96ObjectiveC/)

#### <a name="ios-black-box"></a>6. ios的黑魔盒

`class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)`该函数会根据`sel`返回`objc_method`结构体指针，只要`sel`对应的`IMP`不发生改变，这个结构体指针就不会变，验证如下：

验证一：

```
Method originMethod = class_getInstanceMethod([self class], orginSel);
Method originMethod1 = class_getInstanceMethod([self class], orginSel);

NSLog(@"originMethod: %p", originMethod);
NSLog(@"originMethod1: %p", originMethod);
if (class_addMethod([self class], orginSel, method_getImplementation(overrideMethod) , method_getTypeEncoding(originMethod))) 
{
    originMethod = class_getInstanceMethod([self class], orginSel);
    NSLog(@"originMethod: %p", originMethod);
}

```

输出：

```
2018-06-20 22:12:23.357897+0800 HookDemo[7962:540915] originMethod: 0x1acfcacb0
2018-06-20 22:12:23.358423+0800 HookDemo[7962:540915] originMethod1: 0x1acfcacb0
2018-06-20 22:12:23.358687+0800 HookDemo[7962:540915] originMethod: 0x10099ee28

```

验证二：

```
Method originMethod = class_getInstanceMethod([self class], orginSel);
Method originMethod1 = class_getInstanceMethod([self class], orginSel);

NSLog(@"originMethod: %p", originMethod);
NSLog(@"originMethod1: %p", originMethod);

class_replaceMethod([self class], orginSel, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod));

originMethod = class_getInstanceMethod([self class], orginSel);
NSLog(@"originMethod: %p", originMethod);
```

输出：
```
2018-06-20 22:20:29.814846+0800 HookDemo[8004:543573] originMethod: 0x1acfcacb0
2018-06-20 22:20:29.815427+0800 HookDemo[8004:543573] originMethod1: 0x1acfcacb0
2018-06-20 22:20:29.815481+0800 HookDemo[8004:543573] originMethod: 0x135d76068
```

通过这两个验证实验可知，只要`IMP`发生变化，就会返回不同的`objc_method`结构体指针。接下来我要从`IMP`角度来验证加深对`class_getInstanceMethod`的理解，代码如下：

```
IMP impl1 = method_getImplementation(originMethod);
IMP impl2 = nil;
IMP impl3 = nil;
if (class_addMethod([self class], orginSel, method_getImplementation(overrideMethod) , method_getTypeEncoding(originMethod)))         
{

    impl2 = method_getImplementation(originMethod);
    originMethod = class_getInstanceMethod([self class], orginSel);
    impl3 = method_getImplementation(originMethod);
}
NSLog(@"impl1 %@ impl2", (impl1 == impl2) ? @"==" : @"!=");
NSLog(@"impl2 %@ impl3", (impl2 == impl3) ? @"==" : @"!=");
```

输出：

```
2018-06-20 22:34:33.720940+0800 HookDemo[8068:548091] originMethod: 0x1acfcacb0
2018-06-20 22:34:33.721653+0800 HookDemo[8068:548091] impl1 == impl2
2018-06-20 22:34:33.721701+0800 HookDemo[8068:548091] impl2 != impl3
```

输出结果间接验证了：只要`IMP`发生变化，就会返回不同的`objc_method`结构体指针`originMethod`，这里可以将`class_getInstanceMethod`的实现原理理解为:

* __根据`SEL`和`IMP`来创建`objc_method`对象，并返回地址，如：`originMethod`__

另外有一点要注意：

* __执行`class_addMethod`或者`class_replaceMethod`这种可以改变`IMP`的函数后并不会直接改变`originMethod`所指向的对象(从`impl1 == impl2`可以看出)__

#### <a name="didload-didappear-sequence"></a>7. viewDidLoad, viewDidAppear执行顺序

+ viewDidLoad:视图 load进入内存后调用(loadView[创建view]后执行)
+ viewDidAppear: view显示在屏幕后被调用

#### <a name="singleton"></a>8. Singleton与多线程

singleton的三个基本要素:

+ 静态成员pInstance
+ 静态函数Instance
+ private或protected(可用于继承的场景)构造函数

二元锁/互斥量: 被锁住的代码块是一个执行单元, 只有完整的执行完了, 别的线程才能执行, 所以不存在两个线程同时进入这个代码块.

多线程singleton:

+ 构造函数私有、静态函数访问唯一的实例(普通单例不是线程安全, 多线程下存在多次判断为NULL进而多次new对象的情况)
+ 将分配资源的地方即new对象加锁, 以达到线程安全.(这样加锁, 每一次进入静态函数的时候都会加锁, 我们希望的是: 仅第一次产生实例时才加锁, 非NULL时直接return)

#### <a name="nsdata"></a>9. NSData

NSData是用来包装数据的, NSData存储的是二进制数据, 屏蔽了数据之间的差异, 文本、音频、图像等数据都可用NSData来存储.

#### <a name="ios-filedir"></a>10. iOS 文件目录

iphone沙盒模型的四个文件夹分别是documents，tmp，app，Library. 沙盒目录即home目录.

#### <a name="runloop"></a>11. Runloop

##### Reference

-[1. Runloop blog](https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html)

#### <a name="ios-message"></a>12. ios消息机制

### <a name="ipc"></a>IPC(20180806)

#### Tue Jun  5 21:28:29 CST 2018

&emsp;&emsp;Notes of [Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture). 浏览器的每个tag都是一个独立的进程, 而主进程(browser process或Browser)则管理着这些tab进程(render processes或Renderers)和插件进程. 这些Renderer使用Blink(开源渲染引擎)来解析、布局HTML。主进程和render进程以及他们之间的关系如图所示：

<div align="center">
	<img src="/images/posts/proj_chromium_imgs/arch.png" height="600" width="800">
</div>

$$ 图1. 进程关系(图片引自官网)$$

图中的关键词解释(与进程相关的部分)：

+ ___RenderProcess___: 是 __Renderer__ 中的一个全局对象, 管理着和主进程 __Browser__ 之间的通信同时维持着全局状态.
+ ___RenderProcessHost___: 这是 __Browser__ 中的一个与 __RenderProcess__ 对应的全局对象, 其作用为: a. 管理着主进程 __Browser__ 的状态, b. 与 __RenderProcess__ 通信.

__Browser__ 和 __Renderer__ 之间的进程通信(IPC)通过[Chromium's IPC system](https://www.chromium.org/developers/design-documents/inter-process-communication)实现.

图中的关键词解释(与View相关的部分)：

+ ___RenderView___: 该对象是与标签 ___tab___ 相关的，在每个 __Renderer__ (进程)中有一个或者多个 ___RenderView___ 对象，被 ___RenderProcess___ (前文关键词解释中提到的对象)管理。
+ ___RenderViewHost___: 该对象与 ___Renderer___ 中的每个 ___RenderView___ 对应，相应的受 ___RenderProcessHost___ 管理. 

每个 ___RenderView___ 都有一个view ID, 在同一个 ___Renderer___ 中是唯一确定的, 但是在 ___Browser___ 中却不一定唯一, 因此要确定一个view, 则需要一个 ___RenderProcessHost___ 和一个view ID. ___Browser___ 和view通信需要通过 ___RenderProcessHost___ , 可表示为:

+ ___RenderProcessHost___ --(IPC)-> ___RenderProcess___ ---> ___RenderView___

在Renderer中:

+ ___RenderView___ 通过 ___RenderProcess___ 和与之相应的 ___RenderViewHost___ 交互， 同时与 ___WebKit___ 嵌入层交互, 每个 ___RenderView___ 代表着一个web页面的内容.

在Browser中:

+ ___Browser___ 中有若干个 ___RenderProcessHost___ 与___Renderer___对应.
+ ___RenderViewHost___ 与 ___RenderView___ 交互, 类似的 ___RenderWidgetHost___ 与 ___RenderWidget___交互.

#### Sharing the render process

&emsp;&emsp;通常, 每打开一个tab或者一个window, Browser都会创建一个进程Renderer, 然后Renderer创建一个与这个tab/window相应的RenderView对象. 有时候，我们希望在tab之间共享 ___Render___, 也就是这样一种应用场景: "打开一个tab后, 这个tab共享某一个 ___Renderer___", 亦或是: "当 ___Renderer___ 的个数太多时, 我们把新打开的tab指向某已存在的 ___Renderer___ ". 详细的 ___Renderer___ 重用策略可参看:[Process Models](https://www.chromium.org/developers/design-documents/process-models). 

#### Sandboxing the Renderer

&emsp;&emsp;沙盒机制, 简单来说就是限制 ___Renderer___ 对系统资源如: network、filesystem的访问.

#### Giving back memory

&emsp;&emsp;应用场景主要是: ___low-memory situations___ . 在这种应用场景下处理 ___Renderer___ 内存的一些策略. 

#### Plug-ins and Extension.

&emsp;&emsp;类似于Firefox的NPAPI的插件运行与自己的进程, 而不是在 ___Renderer___ . 详细内容可查阅: [Plugin Architecture](https://www.chromium.org/developers/design-documents/plugin-architecture).

#### Chromium-IPC(Wed Jun  6 15:17:49 CST 2018)

&emsp;&emsp;Chromium利用异步管道(asynchronous pipe)来实现IPC, asynchronous的方式确保了两端不等待对端。

#### IPC in the browser

&emsp;&emsp;在Browser中, 和Renderer的通信是通过一个单独的I/O线程完成的. 主线程发送到Renderer中的view的消息是通过ChannelProxy发出的, 同样的从view发出的消息也要通过代理ChannelProxy发送到主线程, 这种由单独的一个I/O线程来捕获消息的方式主要是为了防止阻塞UI. Brower中的主线程通过RenderProcessHost在Channel中插入ChannelProxy:MessageFilter, 这个filter运行在I/O线程中可以拦截资源请求消息, 然后将其转发到ResourceDispatcherHost.

#### IPC in the renderer

&emsp;&emsp;每个Renderer也有一个专门负责通信的线程(主线程), 然后渲染和其他处理操作在另外一个线程. 从Browser发到Webkit的消息要经由Renderer中的主线程, 反之亦然.

#### Messages

&emsp;&emsp;两个主要的消息类型: routed、control.

+ routed: 请求view渲染一块区域
+ control: 请求资源或修改剪贴板(与view无关的)

&emsp;&emsp;简介几种消息:

+ ___View message___ : 发送给RenderView的消息(Browser ---> Renderer)
+ ___ViewHost message___ : 发送给RenderViewHost的消息(Renderer ---> Browser)
+ ___Frame message___ : 发送给RenderFrame的消息(Browser ---> Renderer)
+ ___FrameHost message___ : 发送给RenderFrameHost的消息(Renderer ---> Browser)
+ ___PluginProcess message___ : 发送给PluginProcess的消息(Browser ---> plugin process)
+ ___PluginProcessHost message___ : 发送给PluginProcessHost的消息(plugin process ---> Browser)

#### 消息声明、消息发送、消息捕获:

&emsp;&emsp; 1. 声明

+ 从Renderer到Browserer的routed消息: IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int)
+ 从Browser到Renderer的control消息: IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage)d
+ 注意: `ipc_message_utils.h`,`navigation_params.h` `frame_messages.h`这是与消息序列化相关的文件.

&emsp;&emsp; 2. 发送

通过channel发送消息, 比如在RenderProcessHost中就包含channel, 这个channel可以把来自于Browser中的UI线程的消息发送给Renderer. 在RenderWidgetHost(为RenderViewHost的基类)中有更为方便的消息发送方式: 即通过Send函数. eg:

+ Send(new ViewMsg_StopFinding(routing_id_));
+ 这里之所以要routing id, 是因为只有这样才可以找到正确的View/ViewHost, 然而我的应用没这个需求.

&emsp;&emsp; 3. 捕获

+ 通过实现IPC::Listener接口来捕获消息, 其中最重要的函数就是`OnMessageReceived`

#### Channels

&emsp;&emsp;IPC:Channel定义了基于pipe的交互方法:

+ IPC:SyncChannel: 同步等待对某些消息的相应(Browser不会用这个方法, Renderer会在"Synchronous messages"用到该方法)

#### synchronous messages

&emsp;&emsp;站在Renderer的角度, 有些消息是要同步的. 比如webkit中的拼写检查和js的cookies, 这些应用的特点是:" 发出一个请求后是需要应答的". eg:

+ webkit发出一个同步类型的IPC请求后, 该请求通过IPC:SyncChannel分发到Renderer中的主线程中的SyncChannel, (这个步骤发送异步消息也是如此), SyncChannel接到这个消息后会阻塞webkit直至SyncChannel接受到一个应答消息后再解除对webkit线程的阻塞. 在webkit阻塞过程中(也就是等待同步消息应答), renderer中的主线程会收到webkit需要处理的消息, 这个时候就需要把这些消息放到webkit的消息队列理, 在webkit线程unlock之后再以此处理这些消息, 可见同步消息的处理是无序的(out-of-order). 同步消息和异步消息使用同样的`IPC_MESSAGE_HANDLER`

#### 小结

&emsp;&emsp;初步把Chromium的IPC理了一遍, 接下来回到[Chromium官方文档的开始部分](https://www.chromium.org/developers/design-documents)继续整理.

### <a name="alpha-blending"></a>$\alpha$-Blending(20180829)

&emsp;&emsp;可以利用$\alpha$通道融合原理在拿不到图片的情况下实现傅立叶变换的线性性质. $\alpha$通道决定了透明度, 称之为$\alpha$ mask. 理论部分很简单, 即: $I = \alpha F +(1 - \alpha) B$.

<br>

转载请注明：[Mengranlin](https://lmrshare.github.io) » [点击阅读原文](https://lmrshare.github.io/2015/09/iOS9_Note/) 
