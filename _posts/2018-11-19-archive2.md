---
layout: post
title: "Archive2"
date: 2018-11-19
description: "Archive2"
tag: Projs
---

定期存档

### 目录

* [IOS项目涉及到的开发知识(20180510)](#ios-relative)
* [IPC(20180806)](#ipc)
* [$\alpha$-Blending(20180829)](#alpha-blending)
* [练习list(20181101)](#opensource)
* [工作中涉及到的操作](#operate)
* [Keras相关的经验](#keras)

### <a name="ios-relative"></a>IOS项目涉及到的开发知识20180510

* [1. ios工程配置相关知识](#ios-config)、[2. 属性和实例变量](#property)、[3. extern、static、const](#esc)、[4. grammar1](#grammar1)、[5. OC与C++混编](#oc-cpp-mex)、[6. ios的黑魔盒](#ios-black-box)、[7. viewDidLoad, viewDidAppear执行顺序](#didload-didappear-sequence)、[8. Singleton与多线程](#singleton)、[9. NSData](#nsdata)、[10. iOS 文件目录](#ios-filedir)、[11. Runloop](#runloop)、[12. ios消息机制](#ios-message)

#### <a name="ios-config"></a>1. ios工程配置相关知识

&emsp;&emsp;一些名词:

+ App ID(Prouct ID): 标识一个或一组App, 与Xcode中的Bundle Identifier一致的或匹配的.
+ CA发布数字证书用以区分通讯各方身份信息.
+ 数字证书: 包含: 公开秘钥[相当于公章]、名称、数字签名; 具有实效性[只在特定的时间段内有效]
+ 根证书: 最根上的证书(如户籍证明), 是信任链的起点.
+ ios证书: 验证App内容是完整、可靠、合法的. 分两类: Development、Production.
+ Development certificate: 用来开发和调试应用程序.
+ Production certificate: 用于分发App.
+ 普通个人开发账号可注册两个Development certificate和两个Development certificate.

&emsp;&emsp;ios app开发调试过程中的开发证书:

+ ios app开发证书的根证书是Apple Worldwide Developer Relations Certification Authority, 他们之间的关系好比于身份证之于户籍.
+ 证书申请: keychain生成CSR[包含开发者身份信息], 同时新增一对public/private key pair. public key随app走, 对app签名进行教研, private key 保存在keychain Access[本地], 以防假冒.
+ Apple Worldwide Developer Relations Certification Authority使用private key对CSR中的public key和开发者身份信息进行加密签名生成数字证书并记录在案.

&emsp;&emsp;证书的安装:

+ 从Apple Member Center下载双击、Xcode添加开发账号自动同步证书和配置文件.
+ build settings > code signing > 配置开发证书.

&emsp;&emsp;Provisioning profile:

+ 打包或真机运行app, 需要: 指明App ID并验证是否于Bundle ID匹配、签名[用证书的私钥签名, 以确定App合法、安全、完整]、确认设备是否授权运行这个app.
+ 而Provisioning profile(pp)涵盖上面提到的: App ID、签名、设备, 它将这三项打包在一起方便在调试和打包时使用, 因此只要在不同的情况下选择不同的pp就行了.
+ pp分为: Development和Distribution两类, 后者主要用于提交到App Store, 这里就不指定设备了.
+ 所有的pp文件被防止在~/Library/MobileDevice/Provisioning Profiles

&emsp;&emsp;开发版pp文件中字段的含义:

+ DeveloperCertificates: 必须这个列表里的证书签名, 否则一定codeSign fail.
+ ProvisionedDevices: 这里配置了设备

&emsp;&emsp;Team PP:

+ 每个Apple开发者账号都对应一个唯一的Team ID.

&emsp;&emsp;App Group

+ ios8以后出现了App Extension, containing App和Extension之间是独立的二进制包, 不可以互访对方的沙盒, extension是containing app的插件.
+ 为了实现containing app和extension之间共享数据, ios 8引入了App Group, 让同一group下的所有app共享数据.
+ extension app ID 于containing app的命名是有规则的.
+ extension app id以containing app id为前缀.
+ 公用证书, 公用证书key pair中的private key进行codeSign

&emsp;&emsp;证书、签名:

+ code signing identity必须与provisioning profile匹配
+ code signing identity中配置的certificate必须在本机keychain access中存在对应的public/private key pair, 否则编译会报错.
+ 上面的合法性验证是WWDRCA.cer完成的.
+ 证书其实就是公钥, 私钥被用来进行数字签名[数字签名就是用哈希算法生成digest]

&emsp;&emsp;真机启动:

+ App在Mac/ios设备上启动时, 会将xcode对其进行的配置与provisioning file(pp)进行匹配校验, 就是看bundle ID是否与app ID匹配, codesign得到的结果是否在pp中, 设备ID是否在pp文件里.
+ ios/mac设备使用codesign所使用的开发证书(dongzhao)来判断App的合法性: 使用证书公钥解出App的signature以确定App是否来源可信; 再计算下app 二进制的哈希结果以确定App没有被篡改过, 内容完整.
+ 基于Provisioning Profile校验了CodeSign的一致性；
+ 基于Certificate校验App的可靠性和完整性；
+ 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。

&emsp;&emsp;多台机器共享开发账户/证书(p12):

+ 在Keychain Access中选中欲导出的certificate或其下private key, 导出p12文件(holds the private key and certificate).
+ 其他Mac机器上双击Certificates.p12即可安装该共享证书. 有了共享证书之后, 在开发者网站上将欲调试的iOS设备注册到该开发者账号名下, 并下载对应证书授权了iOS调试设备的pp文件, 便可在iOS真机设备上开发调试.

##### Reference

- [1. iOS Provisioning Profile(Certificate)与Code Signing详解](http://blog.sina.com.cn/s/blog_82c8198f0102vy4j.html)

#### <a name="property"></a>2. 属性和实例变量

写法一:

```
@interface MyViewController :UIViewController
@property (nonatomic, retain) UIButton *myButton;
@end

```
+ 1. self.myButton调用的是myButton属性的getter/setter方法
+ 2. 实例变量可以理解成C++的成员变量
+ 3. object-c 2.0中@property会自动创建_开头的实例变量

写法二:

```
#import "ViewController.h"

@interface ViewController ()
@property (nonatomic, strong) UIButton *myButton;
@end

@implementation ViewController
@synthesize myButton;

```

归纳总结:

+ `@synthesize`只能出现在`@implementation`代码段中
+ 让编译器自动生成setter和getter
+ `@synthesize myButton = xxx`这种写法指定了与属性对应的实例变量，那么self.myButton其实操作的是实例变量_xxx, 而不是`myButton`了;
+ `@syncthesize myButton`生成的实例变量是`myButton`，也可理解成操作的是`myButton`, 如果没有`@syncthesize myButton`, 生成的实例变量就是`_myButton`

这四条总结起来就是`@synthesize`映射了属性与实例变量，`self.某某`调用的是实例变量的`setter`和`getter`；默认的映射是与之同名的实例变量(可见有了这个关键字生成的是与之同名的实例变量)；没有这个关键字就默认生成`_某某`的实例变量。简记为"做映射, 操作实例, 默认同名"

属性和实例变量的关系：

+ 属性对成员变量扩充了存取方法;
+ 属性默认会生成带下划线的成员变量;
+ 但只声明了变量，是不会有属性的

属性中的参数: @property(nullable, nonatomic, copy)、@property (class, readonly, strong)

#### <a name="esc"></a>3. extern、static、const

简单总结:

+ extern-全局变量修饰，跨文件访问
+ const-修饰右边变量
+ static-定义开始到文件结尾(修饰全局变量)
+ static-定义开始到函数结束或语句块结束(修饰局部变量)
+ static-本文件使用(修饰函数)

`const static`应用场景：本文件中经常使用的字符串常量。

eg1.:

+ `classA.h`文件:

```
@interface ClassA : NSObject
+ (nullable NSUserDefaults *)sharedUserDefaults;
@end

extern NSString * _Nonnull WWKEPostBoxIdentifierHost;
extern NSString * _Nonnull WWKEPostBoxIdentifierShareExtension;
```

+ `classA.m`文件:

```
#import "ClassA.h"

NSString *APPGROUP_NAME = @"group.com.tencent.ww";

NSString *WWKEPostBoxIdentifierHost = @"host";
NSString *WWKEPostBoxIdentifierShareExtension = @"shareext";

@implementation ClassA
+ (nullable NSUserDefaults *)sharedUserDefaults{
    return [[NSUserDefaults alloc] initWithSuiteName:APPGROUP_NAME];
}

@end
```

+ `classB.h`文件：

```
#import "ClassA.h"

@interface ClassB : ClassA

@end

extern NSString * _Nonnull WWKEPostBoxIdentifierShareExtension1;
```

+ `classB.m`文件：

```
    NSString * WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];

    @implementation ClassB
    + (nullable NSUserDefaults *)sharedUserDefaults{
        WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];
        return [[NSUserDefaults alloc] initWithSuiteName:@"sss"];
    }

    @end
```

`NSString * WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];`这行有bug:

```
nitializer element is not a compile-time constant
```

想得通, `WWKEPostBoxIdentifierShareExtension`初始化的时机不能保证在这行之前完成，因此有这个bug。注意，`WWKEPostBoxIdentifierShareExtension1 = [WWKEPostBoxIdentifierShareExtension copy];`这行是没问题的，这说明此时`WWKEPostBoxIdentifierShareExtension`已经初始化完毕。

eg2:

+ `classA.h`和`classA.m`文件不变，`classB.h`变成：

```
#import "ClassA.h"

@interface ClassB : ClassA

@end

```

+ `classB.m`变成：

```
#import "ClassB.h"

NSString *WWKEPostBoxIdentifierHost = @"host";
NSString *WWKEPostBoxIdentifierShareExtension = @"shareext";

@implementation ClassB

@end
```

此时会报链接错误, 注意，`extern`修饰的变量不要出现两次初始化。经调试，只要把任意一处的初始化删掉一个都可通过编译。

##### Reference

- [1. OC中关键字extern、static、const探究](https://www.jianshu.com/p/3fa703e80720)

#### <a name="grammar1"></a>4. grammar1

+ NSUserDefaults: 通过`NSUserDefaults`访问plist文件中的偏好设置
+ 写在`.h`和`.m`中的`@property`有什么区别: 初步看是作用域的问题，后续仔细看下[`@property`](https://jiangxh1992.github.io/ios/2016/10/31/Property%E5%B1%9E%E6%80%A7/)学习下`property`
+ NSFileCoordinator是协调在host app与extension apps之间移动数据的非UI组件
+ CFNotificationCenterGetDarwinNotifyCenter: 1. 系统级的通知中心, 可用于Extension和容器app的交互, 2. NSNotificationCenter，KVO，Delegate都不行，因为Extension和容器app不是一个App. 此外，如果想实现更复杂的进程间的交互，可以使用`MMWormhole`
+ Category和Extension: 一种对类进行扩展的方法， 无需创建子类就可以添加新方法, 可以为任何已经存在的class添加方法, 包括没有源码的类.

##### Reference

- [1. NSUserDefaults](https://www.jianshu.com/p/459c15cf6ce2)
- [2. NSFileCoordinator](https://www.jianshu.com/p/3e3674630190)
- [3. 为什么用](https://www.jianshu.com/p/e807ee6e46e5)

`@class`说明

+ @class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
+ 编译效率和循环引用的问题。

`NSTimeInterval _start = [[NSDate date] timeIntervalSinceReferenceDate];`

+ 时间相关语法

nonatomic

+ 在ios中，一般都声明为非原子的，这处于性能的考虑
+ 在mac OS X中，可以声明为atomic, 因为在mac上不需要怎么考虑性能问题
+ 即使是atomic也不一定能保证是线程安全的，还需要更深层次的锁定机制才行[]

strong与weak

+ ARC是编译器特性而不是运行时特性, 因此不是类似于其他语言的垃圾回收器，其性能与手动内存管理是一样的
+ Strong指针的特点就是可以保持对象的生命，也就是说：当指针获得新值或者不存在时(如局部变量方法返回、实例变量对象释放)对象可能被释放。之所以这里说的是"可能"，理由在于：一个对象可以有多个"拥有者"
+ 默认所有实例变量和局部变量都是Strong指针
+ weak型的指针变量仍然可以指向一个对象，但是不属于对象的拥有者. 也就是说只有使用权, 而不会影响对象的回收。
+ weak型的指针变量自动变为nil是非常方便的，这样阻止了weak指针继续指向已释放对象，避免了野指针的产生，不然会导致非常难于寻找的Bug，空指针消除了类似的问题(野指针跟阳痿差不多)
+ weak指针主要用于“父-子”关系
+ 有了ARC之后，只需要关心对象之间的关联，也就是"谁是谁的拥有者"

##### Reference

- [1. strong属性与weak属性的区别](https://www.jianshu.com/p/f9e5b3f9c088)

#### <a name="oc-cpp-mex"></a>5. OC与C++混编

主要总结C++调用OC的三种情况：

+ 在C++的头文件中写个struct把oc对象藏起来
+ 在C++的头文件中这样`id xxx`
+ 通过c的函数指针把C++和OC结合起来
+ OC对象里函数指针包起实际调用的方法
+ 把OC本身通过void*传给C++对象(与调用无关，只是传递)
+ 把OC的函数指针传给C++对象

详细介绍见参考文章

##### Reference

- [1. 混编](https://awhisper.github.io/2016/05/01/%E6%B7%B7%E7%BC%96ObjectiveC/)

#### <a name="ios-black-box"></a>6. ios的黑魔盒

`class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)`该函数会根据`sel`返回`objc_method`结构体指针，只要`sel`对应的`IMP`不发生改变，这个结构体指针就不会变，验证如下：

验证一：

```
Method originMethod = class_getInstanceMethod([self class], orginSel);
Method originMethod1 = class_getInstanceMethod([self class], orginSel);

NSLog(@"originMethod: %p", originMethod);
NSLog(@"originMethod1: %p", originMethod);
if (class_addMethod([self class], orginSel, method_getImplementation(overrideMethod) , method_getTypeEncoding(originMethod))) 
{
    originMethod = class_getInstanceMethod([self class], orginSel);
    NSLog(@"originMethod: %p", originMethod);
}

```

输出：

```
2018-06-20 22:12:23.357897+0800 HookDemo[7962:540915] originMethod: 0x1acfcacb0
2018-06-20 22:12:23.358423+0800 HookDemo[7962:540915] originMethod1: 0x1acfcacb0
2018-06-20 22:12:23.358687+0800 HookDemo[7962:540915] originMethod: 0x10099ee28

```

验证二：

```
Method originMethod = class_getInstanceMethod([self class], orginSel);
Method originMethod1 = class_getInstanceMethod([self class], orginSel);

NSLog(@"originMethod: %p", originMethod);
NSLog(@"originMethod1: %p", originMethod);

class_replaceMethod([self class], orginSel, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod));

originMethod = class_getInstanceMethod([self class], orginSel);
NSLog(@"originMethod: %p", originMethod);
```

输出：
```
2018-06-20 22:20:29.814846+0800 HookDemo[8004:543573] originMethod: 0x1acfcacb0
2018-06-20 22:20:29.815427+0800 HookDemo[8004:543573] originMethod1: 0x1acfcacb0
2018-06-20 22:20:29.815481+0800 HookDemo[8004:543573] originMethod: 0x135d76068
```

通过这两个验证实验可知，只要`IMP`发生变化，就会返回不同的`objc_method`结构体指针。接下来我要从`IMP`角度来验证加深对`class_getInstanceMethod`的理解，代码如下：

```
IMP impl1 = method_getImplementation(originMethod);
IMP impl2 = nil;
IMP impl3 = nil;
if (class_addMethod([self class], orginSel, method_getImplementation(overrideMethod) , method_getTypeEncoding(originMethod)))         
{

    impl2 = method_getImplementation(originMethod);
    originMethod = class_getInstanceMethod([self class], orginSel);
    impl3 = method_getImplementation(originMethod);
}
NSLog(@"impl1 %@ impl2", (impl1 == impl2) ? @"==" : @"!=");
NSLog(@"impl2 %@ impl3", (impl2 == impl3) ? @"==" : @"!=");
```

输出：

```
2018-06-20 22:34:33.720940+0800 HookDemo[8068:548091] originMethod: 0x1acfcacb0
2018-06-20 22:34:33.721653+0800 HookDemo[8068:548091] impl1 == impl2
2018-06-20 22:34:33.721701+0800 HookDemo[8068:548091] impl2 != impl3
```

输出结果间接验证了：只要`IMP`发生变化，就会返回不同的`objc_method`结构体指针`originMethod`，这里可以将`class_getInstanceMethod`的实现原理理解为:

* __根据`SEL`和`IMP`来创建`objc_method`对象，并返回地址，如：`originMethod`__

另外有一点要注意：

* __执行`class_addMethod`或者`class_replaceMethod`这种可以改变`IMP`的函数后并不会直接改变`originMethod`所指向的对象(从`impl1 == impl2`可以看出)__

#### <a name="didload-didappear-sequence"></a>7. viewDidLoad, viewDidAppear执行顺序

+ viewDidLoad:视图 load进入内存后调用(loadView[创建view]后执行)
+ viewDidAppear: view显示在屏幕后被调用

#### <a name="singleton"></a>8. Singleton与多线程

singleton的三个基本要素:

+ 静态成员pInstance
+ 静态函数Instance
+ private或protected(可用于继承的场景)构造函数

二元锁/互斥量: 被锁住的代码块是一个执行单元, 只有完整的执行完了, 别的线程才能执行, 所以不存在两个线程同时进入这个代码块.

多线程singleton:

+ 构造函数私有、静态函数访问唯一的实例(普通单例不是线程安全, 多线程下存在多次判断为NULL进而多次new对象的情况)
+ 将分配资源的地方即new对象加锁, 以达到线程安全.(这样加锁, 每一次进入静态函数的时候都会加锁, 我们希望的是: 仅第一次产生实例时才加锁, 非NULL时直接return)

#### <a name="nsdata"></a>9. NSData

NSData是用来包装数据的, NSData存储的是二进制数据, 屏蔽了数据之间的差异, 文本、音频、图像等数据都可用NSData来存储.

#### <a name="ios-filedir"></a>10. iOS 文件目录

iphone沙盒模型的四个文件夹分别是documents，tmp，app，Library. 沙盒目录即home目录.

#### <a name="runloop"></a>11. Runloop

##### Reference

-[1. Runloop blog](https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html)

#### <a name="ios-message"></a>12. ios消息机制

### <a name="ipc"></a>IPC(20180806)

#### Tue Jun  5 21:28:29 CST 2018

&emsp;&emsp;Notes of [Multi-process Architecture](https://www.chromium.org/developers/design-documents/multi-process-architecture). 浏览器的每个tag都是一个独立的进程, 而主进程(browser process或Browser)则管理着这些tab进程(render processes或Renderers)和插件进程. 这些Renderer使用Blink(开源渲染引擎)来解析、布局HTML。主进程和render进程以及他们之间的关系如图所示：

<div align="center">
	<img src="/images/posts/proj_chromium_imgs/arch.png" height="600" width="800">
</div>

$$ 图1. 进程关系(图片引自官网)$$

图中的关键词解释(与进程相关的部分)：

+ ___RenderProcess___: 是 __Renderer__ 中的一个全局对象, 管理着和主进程 __Browser__ 之间的通信同时维持着全局状态.
+ ___RenderProcessHost___: 这是 __Browser__ 中的一个与 __RenderProcess__ 对应的全局对象, 其作用为: a. 管理着主进程 __Browser__ 的状态, b. 与 __RenderProcess__ 通信.

__Browser__ 和 __Renderer__ 之间的进程通信(IPC)通过[Chromium's IPC system](https://www.chromium.org/developers/design-documents/inter-process-communication)实现.

图中的关键词解释(与View相关的部分)：

+ ___RenderView___: 该对象是与标签 ___tab___ 相关的，在每个 __Renderer__ (进程)中有一个或者多个 ___RenderView___ 对象，被 ___RenderProcess___ (前文关键词解释中提到的对象)管理。
+ ___RenderViewHost___: 该对象与 ___Renderer___ 中的每个 ___RenderView___ 对应，相应的受 ___RenderProcessHost___ 管理. 

每个 ___RenderView___ 都有一个view ID, 在同一个 ___Renderer___ 中是唯一确定的, 但是在 ___Browser___ 中却不一定唯一, 因此要确定一个view, 则需要一个 ___RenderProcessHost___ 和一个view ID. ___Browser___ 和view通信需要通过 ___RenderProcessHost___ , 可表示为:

+ ___RenderProcessHost___ --(IPC)-> ___RenderProcess___ ---> ___RenderView___

在Renderer中:

+ ___RenderView___ 通过 ___RenderProcess___ 和与之相应的 ___RenderViewHost___ 交互， 同时与 ___WebKit___ 嵌入层交互, 每个 ___RenderView___ 代表着一个web页面的内容.

在Browser中:

+ ___Browser___ 中有若干个 ___RenderProcessHost___ 与___Renderer___对应.
+ ___RenderViewHost___ 与 ___RenderView___ 交互, 类似的 ___RenderWidgetHost___ 与 ___RenderWidget___交互.

#### Sharing the render process

&emsp;&emsp;通常, 每打开一个tab或者一个window, Browser都会创建一个进程Renderer, 然后Renderer创建一个与这个tab/window相应的RenderView对象. 有时候，我们希望在tab之间共享 ___Render___, 也就是这样一种应用场景: "打开一个tab后, 这个tab共享某一个 ___Renderer___", 亦或是: "当 ___Renderer___ 的个数太多时, 我们把新打开的tab指向某已存在的 ___Renderer___ ". 详细的 ___Renderer___ 重用策略可参看:[Process Models](https://www.chromium.org/developers/design-documents/process-models). 

#### Sandboxing the Renderer

&emsp;&emsp;沙盒机制, 简单来说就是限制 ___Renderer___ 对系统资源如: network、filesystem的访问.

#### Giving back memory

&emsp;&emsp;应用场景主要是: ___low-memory situations___ . 在这种应用场景下处理 ___Renderer___ 内存的一些策略. 

#### Plug-ins and Extension.

&emsp;&emsp;类似于Firefox的NPAPI的插件运行与自己的进程, 而不是在 ___Renderer___ . 详细内容可查阅: [Plugin Architecture](https://www.chromium.org/developers/design-documents/plugin-architecture).

#### Chromium-IPC(Wed Jun  6 15:17:49 CST 2018)

&emsp;&emsp;Chromium利用异步管道(asynchronous pipe)来实现IPC, asynchronous的方式确保了两端不等待对端。

#### IPC in the browser

&emsp;&emsp;在Browser中, 和Renderer的通信是通过一个单独的I/O线程完成的. 主线程发送到Renderer中的view的消息是通过ChannelProxy发出的, 同样的从view发出的消息也要通过代理ChannelProxy发送到主线程, 这种由单独的一个I/O线程来捕获消息的方式主要是为了防止阻塞UI. Brower中的主线程通过RenderProcessHost在Channel中插入ChannelProxy:MessageFilter, 这个filter运行在I/O线程中可以拦截资源请求消息, 然后将其转发到ResourceDispatcherHost.

#### IPC in the renderer

&emsp;&emsp;每个Renderer也有一个专门负责通信的线程(主线程), 然后渲染和其他处理操作在另外一个线程. 从Browser发到Webkit的消息要经由Renderer中的主线程, 反之亦然.

#### Messages

&emsp;&emsp;两个主要的消息类型: routed、control.

+ routed: 请求view渲染一块区域
+ control: 请求资源或修改剪贴板(与view无关的)

&emsp;&emsp;简介几种消息:

+ ___View message___ : 发送给RenderView的消息(Browser ---> Renderer)
+ ___ViewHost message___ : 发送给RenderViewHost的消息(Renderer ---> Browser)
+ ___Frame message___ : 发送给RenderFrame的消息(Browser ---> Renderer)
+ ___FrameHost message___ : 发送给RenderFrameHost的消息(Renderer ---> Browser)
+ ___PluginProcess message___ : 发送给PluginProcess的消息(Browser ---> plugin process)
+ ___PluginProcessHost message___ : 发送给PluginProcessHost的消息(plugin process ---> Browser)

#### 消息声明、消息发送、消息捕获:

&emsp;&emsp; 1. 声明

+ 从Renderer到Browserer的routed消息: IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int)
+ 从Browser到Renderer的control消息: IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage)d
+ 注意: `ipc_message_utils.h`,`navigation_params.h` `frame_messages.h`这是与消息序列化相关的文件.

&emsp;&emsp; 2. 发送

通过channel发送消息, 比如在RenderProcessHost中就包含channel, 这个channel可以把来自于Browser中的UI线程的消息发送给Renderer. 在RenderWidgetHost(为RenderViewHost的基类)中有更为方便的消息发送方式: 即通过Send函数. eg:

+ Send(new ViewMsg_StopFinding(routing_id_));
+ 这里之所以要routing id, 是因为只有这样才可以找到正确的View/ViewHost, 然而我的应用没这个需求.

&emsp;&emsp; 3. 捕获

+ 通过实现IPC::Listener接口来捕获消息, 其中最重要的函数就是`OnMessageReceived`

#### Channels

&emsp;&emsp;IPC:Channel定义了基于pipe的交互方法:

+ IPC:SyncChannel: 同步等待对某些消息的相应(Browser不会用这个方法, Renderer会在"Synchronous messages"用到该方法)

#### synchronous messages

&emsp;&emsp;站在Renderer的角度, 有些消息是要同步的. 比如webkit中的拼写检查和js的cookies, 这些应用的特点是:" 发出一个请求后是需要应答的". eg:

+ webkit发出一个同步类型的IPC请求后, 该请求通过IPC:SyncChannel分发到Renderer中的主线程中的SyncChannel, (这个步骤发送异步消息也是如此), SyncChannel接到这个消息后会阻塞webkit直至SyncChannel接受到一个应答消息后再解除对webkit线程的阻塞. 在webkit阻塞过程中(也就是等待同步消息应答), renderer中的主线程会收到webkit需要处理的消息, 这个时候就需要把这些消息放到webkit的消息队列理, 在webkit线程unlock之后再以此处理这些消息, 可见同步消息的处理是无序的(out-of-order). 同步消息和异步消息使用同样的`IPC_MESSAGE_HANDLER`

#### 小结

&emsp;&emsp;初步把Chromium的IPC理了一遍, 接下来回到[Chromium官方文档的开始部分](https://www.chromium.org/developers/design-documents)继续整理.

### <a name="alpha-blending"></a>$\alpha$-Blending(20180829)

&emsp;&emsp;可以利用$\alpha$通道融合原理在拿不到图片的情况下实现傅立叶变换的线性性质. $\alpha$通道决定了透明度, 称之为$\alpha$ mask. 理论部分很简单, 即: $I = \alpha F +(1 - \alpha) B$.

### <a name="opensource"></a>练习list(20181101)

* [1. GCDAsyncSocket](#GCDAsyncSocket)、[2. Web_rtc](#webrtc)、[3. 多线程](#multiprocess)、[4. TCP、心跳](#heartbeat)、[5. MRC与ARC](#mrc-arc)、[6. 堆对象、栈对象](#heap-stack-object)、[7. GCD](#gcd)、[8. The Chromium Projects](#chromium-project)

#### <a name="GCDAsyncSocket"></a>1. GCDAsyncSocket

+ source code dir=`/Users/linmengran/work/ios/xuyaohui/CocoaAsyncSocketTip-master/CocoaSyncSocket/Pods/Pods.xcodeproj`
+ 黏包、断包处理实例=`/Users/linmengran/work/ios/xuyaohui/IM_PacketHandle-master`
+ testReplayKit2/GCDAsyncSocketManager-master---我的ipc层主要参考了这个, 这是对AsyncSocket proj的一个封装

抓包:

+ 先关联设备: rvictl -s uuid
+ 再启动wireshark: sudo su、wireshark &
+ 显示设备: rvictl -l
+ 关闭设备: rvictl -x uuid
+ 退出超级管理员: exit

直接关掉wireshark重来会出问题，所以我就用了下面的命令来管理wireshark

+ 查看进程(linux): `ps -ef | grep wireshark`

```
    linmengran$: ps -ef | grep wireshark
    0 37696 13351   0  9:38下午 ttys004    0:00.02 sudo wireshark
    0 37702 37696   0  9:38下午 ttys004    0:08.11 /Applications/Wireshark.app/Contents/Resources/bin/wireshark-bin
    501 39068 13351   0  9:41下午 ttys004    0:00.00 grep wireshark
```

+kill掉这些进程: sudo kill -9 37696 37702 39068

#### <a name="webrtc"></a>2. Web_rtc

P2P连接的特点: 数据通道一旦形成, 中间是不经过服务端的, 数据直接从一个客户端流向另一个客户端. 注意: WebRTC虽然提供了P2P的通信, 但并不意味着WebRTC不需要服务器. 至少有两件事必须要要用到服务器:

+ 浏览器之间交换建立通信的元数据(信令)必须要通过服务器。
+ 为了穿越NAT和防火墙。

NAT:

+ 关于这部分内容先说下结论吧："主动发包的一方被知晓(包括IP/Port，发送方的NAT), 主动方可收包(突破主动方的NAT)"

WebRTC就是根据这一结论, 突破的NAT限制, 做法是:

+ 两端同时向一个公网服务器发包，然后公网向这两端发对端的IP/port, 这样这两端就突破了NAT限制

task:

+ IOS下WebRTC环境搭建：
+ NAT实现
+ ICE协议框架
+ [WebRTC protocols](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Protocols)
+ google "wireshark抓VoIP"

##### Reference

- [1. 下载源码、编译](https://www.jianshu.com/p/64bd7f5b18b1)
- [2. WebRTC protocols](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Protocols)
- [3. ios下音视频通信-基于WebRTC](https://www.jianshu.com/p/c49da1d93df4)

#### <a name="multiprocess"></a>3. 多线程

在项目`/Users/linmengran/work/ios/code_backup/delegate_test/delegate_test.xcodeproj` 练习。我把`NSoperation`之前的撸完了。

##### Reference

- [1. 多线程调试技巧](https://www.jianshu.com/p/35a3181aa1f8)

#### <a name="heartbeat"></a>4. TCP、心跳

心跳：客户端每隔一段时间向服务端发送自定义指令，以判断双方是否存活。(undone)

+ 1. google: "TCP的KeepAlive无法替代应用层的心跳保活机制--连接活着但业务已死"

#### <a name="mrc-arc"></a>5. MRC与ARC

+ 1. 引用计数器操作

##### Reference

- [1. MRC and ARC](https://www.jianshu.com/p/48665652e4e4)

#### <a name="heap-stack-object"></a>6. 堆对象、栈对象

+ 代码区-就是可执行文件的内存镜像，白话来说就是把二进制码怼到内存里
+ 数据区、BSS区-两者的区别就是初始化和未初始化, 我的疑问就是：既然都是全局变量和静态变量为什么还要单独区分？是为了检索效率
+ 常量区-和代码区、数据区的区别就是：常和变的区别。注意：static标识的放在数据区
+ 堆-动态分配的
+ 栈-局部变量、函数参数。注意：函数被调用时再把参数压入调用的进程栈中，白话来说就是谁调用了谁就再压一遍。
+ 6. 为什么用栈，因为方便恢复现场。那么为什么栈容易恢复现场？(undone)

##### Reference

- [1. 堆和栈](https://www.jianshu.com/p/746c747e7e00)

#### <a name="gcd"></a>7. GCD

##### Reference

-[1. GCD](https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8)[undone]

#### <a name="chromium-project"></a>8. The Chromium Projects

+ 成功编译ios工程

##### Reference

- [1. chromium](https://www.chromium.org/developers/design-documents)
- [2. Checking out and building Chromium for iOS](https://chromium.googlesource.com/chromium/src/+/master/docs/ios/build_instructions.md)
- [3. High-level architecture Chromium](https://www.chromium.org/developers/design-documents/multi-process-architecture)
- [4. Chromium基础库说明](https://www.zybuluo.com/rogeryi/note/56894)

### <a name="operate"></a>工作中涉及到的操作

* [1. 调试](#debug-operate)、[2. git](#git-operate)、[3. c++11支持](#cpp11-operate)、[4. nm静态库](#nm-operate)

#### <a name="debug-operate"></a>1. 调试

+ [IOS Debugging Magic](https://developer.apple.com/library/content/technotes/tn2239/_index.html#//apple_ref/doc/uid/DTS40010638)

#### <a name="git-operate"></a>2. git

+ 查看远程分支: git branch -r
+ 提交文件夹下的更新: git add -u xxx/yyy 

commands:

+ git log: review exixting commits
+ git log -p
+ git log --stat
+ git log -p -w
+ git log sha
+ git log --oneline
+ git log -p sha
+ git show : show the recent changes
+ git show sha
+ git diff: Display the difference between two versions of a file, This tool will tell us what changes we've made to files before the files have been committed
+ git tag: add tags to specific commits
+ git branch: Allow multiple lines of development, Let you develop different features of your project in parallel without getting confused as to which commits belong to which feature
+ git checkout: You will be able to switch between different branches and tags#### <a name="cpp11-operate"></a>3. c++11支持
+ git merge: Combine changes on different branches [Take change on different branches and combine them together automatically.]
+ git tag -a v1.0: create an annotated flag, and tag the most recent commit.
+ git tag v1.0: create an lightweight tag
+ git tag -a v1.0 a87984: 

verify tag:

+ -git tag
+ -git log --decorate

delete tag:

+ -git tag -d v1.0
+ -git tag --delete v1.0

切分支:

+ git checkout -b feature_xxx_demo remotes/origin/feature_xxx_demo
+ git show 981734907213409712309847

注意事项:

+ commit前diff一下，确定代码有没有冲突
+ 如果commit之前没diff, 我一般会在push之后git log，然后git show


#### <a name="cpp11-operate"></a>3. c++11支持

+ 要支持c++11，需要在CMakeLists.txt中加上这句: add_definitions(-std=c++11)

#### <a name="nm-operate"></a>4. nm静态库

+ `nm /Users/linmengran/work/git/ios/xxx/ssss | grep Masonry`
+ `grep "\-\->ycyc" tmp.txt`
+ `grep "sent" ~/Documents/console.log | head -5k`


### <a name="keras"></a>Keras相关的经验

Exp1：

    plot_model(model, to_file='model.png',show_shapes=True)----这行代码可以将model保存成图片。

    model.summary(): 打印出模型的概况

Exp2：

    1. isinstance---isinstance(object,type-or-tuple-or-class) -> bool
    2. python 创建类、继承、抽象方法
       class xx(object):
         @abstractmethod
         def xxx(self, xx1,xx2):
    3. python的threading

Exp3：

    1. dataset_dict = {'smart':Smartiterator, 'discovery':DicoveryIterator}
    2. dataset_dict['smart'](dir,args)

Exp4：

    1. from utils.eval_utils import get_metrics --- 从utils文件夹下的eval_utils.py文件导入get_metrics函数

Exp5：

    metric = (lambda f, t : lambda gt, pred : f(gt, pred, t))(metric_func, thresh)

Exp6：

我对这句的理解: `lambda f, t : lambda gt, pred : f(gt, pred, t)` 是函数部分, `(metric_func, thresh)` 是参数部分。起初，我认为可以等价为:

    metric = lambda gt, pred : metric_func(gt, pred, thresh)

经测验这是错误的, 原因在于：这里的`metric_func`不再是具体的函数，没有意义。举例说明:

    >>> func3 = lambda x, y, z : x + y + z
    >>> F = lambda gt, pred : func3(gt, pred, 2)
    >>> F(1,2)

出错: `***NameError name 'func3' is not defined`

如果把func3当成参数传递就没问题:

    >>> F = (lambda f : lambda gt, pred : f(gt, pred, 2))(func3)
    >>> F(1,2)
    5

简记：看到`lambda`, 配对，带入。

python 中`lambda`的用法：

_eg1_:

    >>> func = lambda a, b : a+b
    >>> func(1,3)
    >>> 4

_eg2_:

    def func(n)
      return lambda x, n : x + n

    >>> f = func(3)
    >>> f(2)
    >>> 5

_eg3(作为一个小函数传递:)_:

    >>> pairs = [(4, 'four'), (3, 'three'), (2, 'two'), (1, 'one')]
    >>> pairs
    [(4, 'four'), (3, 'three'), (2, 'two'), (1, 'one')]
    >>> pairs.sort(key = lambda pair : pair[0])
    >>> pairs
    [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]

返回类型:

    >>> type(xx)



<br>

转载请注明：[Mengranlin](https://lmrshare.github.io) » [点击阅读原文](https://lmrshare.github.io/2015/09/iOS9_Note/) 
